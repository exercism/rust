/// This module contains source for the `generate` command.
use serde_json::Value as JsonValue;
use std::{
    collections::HashMap,
    fs::{self, File, OpenOptions},
    io::Write,
    path::Path,
    process::{Command, Stdio},
};
use toml::Value as TomlValue;
use utils;

static GITIGNORE_CONTENT: &'static str = "# Generated by Cargo
# will have compiled files and executables
/target/
**/*.rs.bk

# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries
# More information here http://doc.crates.io/guide.html#cargotoml-vs-cargolock
Cargo.lock
";

static EXAMPLE_RS_CONTENT: &'static str = "//! Example implementation
//!
//! - Implement the solution to your exercise here.
//! - Put the stubs for any tested functions in `src/lib.rs`,
//!   whose variable names are `_` and
//!   whose contents are `unimplemented!()`.
//! - If your example implementation has dependencies, copy
//!   `Cargo.toml` into `Cargo-example.toml` and then make
//!   any modifications necessary to the latter so your example will run.
//! - Test your example by running `../../bin/test-exercise`
";

// Generate .meta directory and it's contents without using the canonical data
fn generate_default_meta(exercise_name: &str, exercise_path: &Path) {
    fs::create_dir(exercise_path.join(".meta")).expect("Failed to create the .meta directory");

    fs::write(
        exercise_path.join(".meta").join("description.md"),
        "Describe your exercise here.\n\nDon't forget that `README.md` is automatically generated; update this within `.meta/description.md`.",
    ).expect("Failed to create .meta/description.md file");

    fs::write(
        exercise_path.join(".meta").join("metadata.yml"),
        format!(
            "---\nblurb: \"{}\"\nsource: \"\"\nsource_url: \"\"",
            exercise_name
        ),
    ).expect("Failed to create .meta/metadata.yml file");

    let mut tests_file = OpenOptions::new()
        .append(true)
        .open(
            exercise_path
                .join("tests")
                .join(format!("{}.rs", exercise_name)),
        ).unwrap();

    tests_file.write_all(b"// Add your tests here").unwrap();
}

// Update Cargo.toml of the generated exercise according to the fetched canonical data
fn update_cargo_toml(exercise_name: &str, exercise_path: &Path, canonical_data: &JsonValue) {
    let cargo_toml_content =
        fs::read_to_string(exercise_path.join("Cargo.toml")).expect("Error reading Cargo.toml");

    let mut cargo_toml: TomlValue = cargo_toml_content.parse().unwrap();

    {
        let package_table = (&mut cargo_toml["package"]).as_table_mut().unwrap();

        package_table.insert(
            "version".to_string(),
            TomlValue::String(canonical_data["version"].as_str().unwrap().to_string()),
        );

        package_table.insert(
            "name".to_string(),
            TomlValue::String(exercise_name.replace("-", "_")),
        );
    }

    fs::write(exercise_path.join("Cargo.toml"), cargo_toml.to_string())
        .expect("Failed to update Cargo.toml file");
}

// Generate test suite using the canonical data
fn generate_tests_from_canonical_data(
    exercise_name: &str,
    exercise_path: &Path,
    canonical_data: &JsonValue,
    use_maplit: bool,
) {
    update_cargo_toml(exercise_name, exercise_path, canonical_data);

    let tests_path = exercise_path
        .join("tests")
        .join(format!("{}.rs", exercise_name));

    let tests_content = utils::get_tests_content(exercise_name).unwrap_or_else(|_| {
        panic!(
            "Failed to get the content of the test suite for the '{}' exercise. Aborting.",
            exercise_name
        )
    });

    let updated_tests_content = format!(
        "//! Tests for {} \n\
        //! \n\
        //! Generated by [utility][utility] using [canonical data][canonical_data] \n\
        //! \n\
        //! [utility]: {} \n\
        //! [canonical_data]: {} \n\
        \n\
        {} \n\
        ", exercise_name, env!("CARGO_PKG_NAME"), format!("https://raw.githubusercontent.com/exercism/problem-specifications/master/exercises/{}/canonical-data.json", exercise_name), tests_content);

    fs::write(&tests_path, updated_tests_content)
        .expect("Failed to update the content of the test suite");

    let mut property_functions: HashMap<&str, String> = HashMap::new();

    let mut test_functions: Vec<String> = Vec::new();

    let cases = canonical_data.get("cases").unwrap();

    for case in cases.as_array().unwrap().iter() {
        if let Some(sub_cases) = case.get("cases") {
            for sub_case in sub_cases.as_array().unwrap().iter() {
                if let Some(property) = sub_case.get("property") {
                    let property = property.as_str().unwrap();

                    if !property_functions.contains_key(property) {
                        property_functions
                            .insert(property, utils::generate_property_body(property));
                    }
                }

                test_functions.push(utils::generate_test_function(&sub_case, use_maplit));
            }
        } else {
            if let Some(property) = case.get("property") {
                let property = property.as_str().unwrap();

                if !property_functions.contains_key(property) {
                    property_functions.insert(property, utils::generate_property_body(property));
                }
            }

            test_functions.push(utils::generate_test_function(&case, use_maplit));
        }
    }

    if !test_functions.is_empty() {
        let first_test_function = test_functions.remove(0).replace("#[ignore]\n", "");

        test_functions.insert(0, first_test_function);
    }

    let mut tests_file = OpenOptions::new().append(true).open(&tests_path).unwrap();

    for (property, property_body) in &property_functions {
        tests_file
            .write_all(property_body.as_bytes())
            .unwrap_or_else(|_| {
                panic!(
                    "Failed to add {} property function to the tests file",
                    property
                )
            });
    }

    tests_file
        .write_all(test_functions.join("\n\n").as_bytes())
        .unwrap_or_else(|_| panic!("Failed to add test functions to the test file"));

    // FIXME: The algorithm is Unix-specific and will always fail on Windows. General solution required
    if let Ok(which_output) = Command::new("which").arg("rustfmt").output() {
        if !String::from_utf8_lossy(&which_output.stdout)
            .trim()
            .is_empty()
        {
            Command::new("rustfmt")
                .arg(&tests_path)
                .output()
                .expect("Failed to run rustfmt command on the test suite file");
        }
    }
}

// Run bin/configlet generate command to generate README for the exercise
fn generate_readme(exercise_name: &str, track_root: &str) {
    println!(
        "Generating README for {} via 'bin/configlet generate'",
        exercise_name
    );

    let problem_specifications_path = Path::new(track_root)
        .join("..")
        .join("problem-specifications");

    if !problem_specifications_path.exists() {
        let problem_specifications_url = "https://github.com/exercism/problem-specifications.git";
        println!(
            "problem-specifications repository not found. Cloning the repository from {}",
            problem_specifications_url
        );

        Command::new("git")
            .current_dir(track_root)
            .stdout(Stdio::inherit())
            .arg("clone")
            .arg(problem_specifications_url)
            .arg(&problem_specifications_path)
            .output()
            .expect("Failed to clone problem-specifications repo");
    }

    utils::run_configlet_command(
        "generate",
        &[
            ".",
            "--only",
            exercise_name,
            "--spec-path",
            problem_specifications_path.to_str().unwrap(),
        ],
    );
}

// Generate a new exercise with specified name and flags
pub fn generate_exercise(exercise_name: &str, use_maplit: bool) {
    let track_root = utils::get_track_root();

    let exercise_path = Path::new(&track_root).join("exercises").join(exercise_name);

    if exercise_path.exists() {
        panic!(
            "Exercise with the name {} already exists. Aborting",
            exercise_name
        );
    }

    println!(
        "Generating a new exercise at the following path: {}",
        exercise_path.to_str().unwrap()
    );

    let _cargo_new_output = Command::new("cargo")
        .arg("new")
        .arg("--lib")
        .arg(exercise_path.to_str().unwrap())
        .output()
        .expect("Failed to generate a new exercise via 'cargo new' command");

    fs::write(exercise_path.join(".gitignore"), GITIGNORE_CONTENT)
        .expect("Failed to create .gitignore file");

    if use_maplit {
        let mut cargo_toml_file = OpenOptions::new()
            .append(true)
            .open(exercise_path.join("Cargo.toml"))
            .unwrap();

        cargo_toml_file
            .write_all(b"maplit = \"1.0.1\"")
            .expect("Failed to add maplit dependency to the Cargo.toml");
    }

    fs::create_dir(exercise_path.join("tests")).expect("Failed to create the tests directory");

    let mut test_file = File::create(
        exercise_path
            .join("tests")
            .join(format!("{}.rs", exercise_name)),
    ).expect("Failed to create test suite file");

    if use_maplit {
        test_file
            .write_all(b"#[macro_use]\nextern crate maplit;\n")
            .expect("Failed to append maplit crate to the test file.");
    }

    test_file
        .write_all(&format!("extern crate {};\n", exercise_name.replace("-", "_")).into_bytes())
        .unwrap();

    test_file
        .write_all(&format!("use {}::*;\n\n", exercise_name.replace("-", "_")).into_bytes())
        .unwrap();

    fs::write(exercise_path.join("example.rs"), EXAMPLE_RS_CONTENT)
        .expect("Failed to create example.rs file");

    if let Some(canonical_data) = utils::get_canonical_data(exercise_name) {
        println!("Generating tests from canonical data");

        generate_tests_from_canonical_data(
            &exercise_name,
            &exercise_path,
            &canonical_data,
            use_maplit,
        );
    } else {
        println!(
            "No canonical data for exercise '{}' found. Generating standard exercise template.",
            &exercise_name
        );

        generate_default_meta(&exercise_name, &exercise_path);
    }

    generate_readme(&exercise_name, &track_root);
}
