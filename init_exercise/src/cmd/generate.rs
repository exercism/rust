/// This module contains source for the `generate` command.
use clap::ArgMatches;
use reqwest::{self, StatusCode};
use serde_json::Value as JsonValue;
use std::{
    collections::HashMap,
    fs::{self, File, OpenOptions},
    io::Write,
    path::Path,
    process::Command,
};
use toml::Value as TomlValue;

static GITIGNORE_CONTENT: &'static str = "# Generated by Cargo
# will have compiled files and executables
/target/
**/*.rs.bk

# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries
# More information here http://doc.crates.io/guide.html#cargotoml-vs-cargolock
Cargo.lock
";

static EXAMPLE_RS_CONTENT: &'static str = "//! Example implementation
//!
//! - Implement the solution to your exercise here.
//! - Put the stubs for any tested functions in `src/lib.rs`,
//!   whose variable names are `_` and
//!   whose contents are `unimplemented!()`.
//! - If your example implementation has dependencies, copy
//!   `Cargo.toml` into `Cargo-example.toml` and then make
//!   any modifications necessary to the latter so your example will run.
//! - Test your example by running `../../bin/test-exercise`
";

// Try to get the canonical data for the exercise of the given name
fn get_canonical_data(exercise_name: &str) -> Option<JsonValue> {
    let url = format!("https://raw.githubusercontent.com/exercism/problem-specifications/master/exercises/{}/canonical-data.json", exercise_name);

    let mut response =
        reqwest::get(&url).expect("Failed to make HTTP request for the canonical data.");

    if response.status() != StatusCode::Ok {
        return None;
    } else {
        return Some(
            response
                .json()
                .expect("Failed to parse the JSON canonical-data response"),
        );
    }
}

// Generate .meta directory and it's contents without using the canonical data
fn generate_default_meta(exercise_name: &str, exercise_path: &Path) {
    fs::create_dir(exercise_path.join(".meta")).expect("Failed to create the .meta directory");

    fs::write(
        exercise_path.join(".meta").join("description.md"),
        "Describe your exercise here.\n\nDon't forget that `README.md` is automatically generated; update this within `.meta/description.md`.",
    ).expect("Failed to create .meta/description.md file");

    fs::write(
        exercise_path.join(".meta").join("metadata.yml"),
        format!(
            "---\nblurb: \"{}\"\nsource: \"\"\nsource_url: \"\"",
            exercise_name
        ),
    ).expect("Failed to create .meta/metadata.yml file");

    let mut tests_file = OpenOptions::new()
        .append(true)
        .open(
            exercise_path
                .join("tests")
                .join(format!("{}.rs", exercise_name)),
        )
        .unwrap();

    tests_file.write(b"// Add your tests here").unwrap();
}

// Update Cargo.toml of the generated exercise according to the fetched canonical data
fn update_cargo_toml(exercise_name: &str, exercise_path: &Path, canonical_data: &JsonValue) {
    let cargo_toml_content =
        fs::read_to_string(exercise_path.join("Cargo.toml")).expect("Error reading Cargo.toml");

    let mut cargo_toml: TomlValue = cargo_toml_content.parse().unwrap();

    {
        let mut package_table = (&mut cargo_toml["package"]).as_table_mut().unwrap();

        package_table.insert(
            "version".to_string(),
            TomlValue::String(canonical_data["version"].as_str().unwrap().to_string()),
        );

        package_table.insert(
            "name".to_string(),
            TomlValue::String(exercise_name.replace("-", "_")),
        );
    }

    fs::write(exercise_path.join("Cargo.toml"), cargo_toml.to_string())
        .expect("Failed to update Cargo.toml file");
}

fn generate_property_body<'a>(
    property_functions: &mut HashMap<&'a str, String>,
    case: &'a JsonValue,
) {
    if let Some(property) = case.get("property") {
        let property = property.as_str().unwrap();

        if property_functions.contains_key(property) {
            return;
        }

        let property_function_body = format!(
            "\
             /// Process a single test case for the property `{property}`\n\
             ///\n\
             /// All cases for the `{property}` property are implemented\n\
             /// in terms of this function.\n\
             /// \n\
             /// Note that you'll need to both name the expected transform which\n\
             /// the student needs to write, and name the types of the inputs and outputs.\n\
             /// While rustc _may_ be able to handle things properly given a working example,\n\
             /// students will face confusing errors if the `I` and `O` types are not concrete.\n\
             /// \n\
             fn process_{property_lower}_case<I, O>(input: I, expected: O) {{\n\
             //  typical implementation:\n\
             //  assert_eq!(\n\
             //      student_{property_lower}_func(input),\n\
             //      expected\n\
             //  )\n    unimplemented!()\n\
             }}\n\
             \n\
             ",
            property = property,
            property_lower = property.to_lowercase().replace("-", "_")
        );

        property_functions.insert(property, property_function_body);
    }
}

// Generate test suite using the canonical data
fn generate_tests_from_canonical_data(
    exercise_name: &str,
    exercise_path: &Path,
    canonical_data: &JsonValue,
    use_maplit: bool,
) {
    update_cargo_toml(exercise_name, exercise_path, canonical_data);

    let tests_path = exercise_path
        .join("tests")
        .join(format!("{}.rs", exercise_name));

    let tests_content =
        fs::read_to_string(&tests_path).expect("Failed to read existing tests content.");

    let updated_tests_content = format!(
        "//! Tests for {} \n\
        //! \n\
        //! Generated by [utility][utility] using [canonical data][canonical_data] \n\
        //! \n\
        //! [utility]: {} \n\
        //! [canonical_data]: {} \n\
        \n\
        {} \n\
        ", exercise_name, env!("CARGO_PKG_NAME"), format!("https://raw.githubusercontent.com/exercism/problem-specifications/master/exercises/{}/canonical-data.json", exercise_name), tests_content);

    fs::write(&tests_path, updated_tests_content)
        .expect("Failed to update the content of the test suite");

    let mut property_functions: HashMap<&str, String> = HashMap::new();

    let cases = canonical_data.get("cases").unwrap();

    for case in cases.as_array().unwrap().into_iter() {
        if let Some(sub_cases) = case.get("cases") {
            for sub_case in sub_cases.as_array().unwrap().into_iter() {
                generate_property_body(&mut property_functions, &sub_case);
            }
        } else {
            generate_property_body(&mut property_functions, &case);
        }
    }

    let mut tests_file = OpenOptions::new().append(true).open(tests_path).unwrap();

    for (property, property_body) in property_functions.iter() {
        tests_file.write(property_body.as_bytes()).expect(&format!(
            "Failed to add {} property function to the tests file",
            property
        ));
    }
}

// Generate a new exercise with specified name and flags
fn generate_exercise(exercise_name: &str, run_configure: bool, use_maplit: bool) {
    let rev_parse_output = Command::new("git")
        .arg("rev-parse")
        .arg("--show-toplevel")
        .output()
        .expect("Failed to get the path to the track repo.");

    let track_root = String::from_utf8(rev_parse_output.stdout).unwrap();

    let exercise_path = Path::new(&track_root.trim())
        .join("exercises")
        .join(exercise_name);

    if exercise_path.exists() {
        panic!(
            "Exercise with the name {} already exists. Aborting",
            exercise_name
        );
    }

    println!(
        "Generating a new exercise at the following path: {}",
        exercise_path.to_str().unwrap()
    );

    let _cargo_new_output = Command::new("cargo")
        .arg("new")
        .arg("--lib")
        .arg(exercise_path.to_str().unwrap())
        .output()
        .expect("Failed to generate a new exercise via 'cargo new' command");

    fs::write(exercise_path.join(".gitignore"), GITIGNORE_CONTENT)
        .expect("Failed to create .gitignore file");

    if use_maplit {
        let mut cargo_toml_file = OpenOptions::new()
            .append(true)
            .open(exercise_path.join("Cargo.toml"))
            .unwrap();

        cargo_toml_file
            .write(b"maplit = \"1.0.1\"")
            .expect("Failed to add maplit dependency to the Cargo.toml");
    }

    fs::create_dir(exercise_path.join("tests")).expect("Failed to create the tests directory");

    let mut test_file = File::create(
        exercise_path
            .join("tests")
            .join(format!("{}.rs", exercise_name)),
    ).expect("Failed to create test suite file");

    if use_maplit {
        test_file.write(b"#[macro_use]\nextern crate maplit;\n");
    }

    test_file
        .write(&format!("extern crate {};\n", exercise_name.replace("-", "_")).into_bytes())
        .unwrap();

    test_file
        .write(&format!("use {}::*;\n\n", exercise_name.replace("-", "_")).into_bytes())
        .unwrap();

    fs::write(exercise_path.join("example.rs"), EXAMPLE_RS_CONTENT)
        .expect("Failed to create example.rs file");

    if let Some(canonical_data) = get_canonical_data(exercise_name) {
        println!("Generating tests from canonical data");

        generate_tests_from_canonical_data(
            &exercise_name,
            &exercise_path,
            &canonical_data,
            use_maplit,
        );
    } else {
        println!(
            "No canonical data for exercise '{}' found. Generating standard exercise template.",
            &exercise_name
        );

        generate_default_meta(&exercise_name, &exercise_path);
    }
}

pub fn process_matches(matches: &ArgMatches) {
    let exercise_name = matches.value_of("exercise_name").unwrap();

    let run_configure = !matches.is_present("no_configure");

    let use_maplit = matches.is_present("use_maplit");

    generate_exercise(exercise_name, run_configure, use_maplit);
}
