{%- macro render_tree(tree) -%}
    Tree::new("{{ tree.label }}")
    {%- if tree.children -%}{%- for child in tree.children -%}
            .with_child({{ self::render_tree(tree=child) }})
    {%- endfor -%}{%- endif -%}
{%- endmacro -%}

{%- macro render_vec(values) -%}
vec![
    {%- for value in values -%}
        &"{{ value }}",
    {%- endfor -%}
]
{%- endmacro -%}

{% for test_group in cases %}
/// {{ test_group.description }}
mod {{ test_group.cases[0].property | make_ident }} {
    use pov::*;
    use pretty_assertions::assert_eq;

{% for test in test_group.cases %}
#[test]
#[ignore]
fn {{ test.description | make_ident }}() {
    let mut tree = {{ self::render_tree(tree=test.input.tree) }};
    let from = "{{ test.input.from }}";
    {%- if test.property == "fromPov" -%}
        {%- if not test.expected -%}
            assert!(!tree.pov_from(&from));
        {%- else -%}
            assert!(tree.pov_from(&from));
            let expected = {{ self::render_tree(tree=test.expected) }};
            assert_eq!(tree, expected);
        {%- endif -%}
    {%- elif test.property == "pathTo" -%}
        let to = "{{ test.input.to }}";
        let result = tree.path_to(&from, &to);
        {%- if not test.expected -%}
            let expected: Option<Vec<_>> = None;
        {%- else -%}
            let expected = Some({{ self::render_vec(values=test.expected) }});
        {%- endif -%}
        assert_eq!(result, expected);
    {%- else -%}
        Invalid property: {{ test.property }}
    {%- endif -%}
}
{% endfor %}
}
{% endfor %}
