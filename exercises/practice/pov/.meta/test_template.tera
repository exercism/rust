{%- macro render_tree(tree) -%}
{%- if tree.children -%}
    Tree::with_children(
        "{{ tree.label }}".to_string(),
        vec![
            {%- for child in tree.children -%}
                {{ self::render_tree(tree=child) }},
            {%- endfor -%}
        ],
    )
{%- else -%}
    Tree::new("{{ tree.label }}".to_string())
{%- endif -%}
{%- endmacro -%}

{%- macro render_vec(values) -%}
vec![
    {%- for value in values -%}
        "{{ value }}".to_string(),
    {%- endfor -%}
]
{%- endmacro -%}

{% for test_group in cases %}
/// {{ test_group.description }}
mod {{ test_group.cases[0].property | make_ident }} {
    use pov::*;
    use pretty_assertions::assert_eq;
{%- if test_group.cases[0].property == "fromPov" -%}
    use super::test_util::tree_to_sorted;
{%- endif %}

{% for test in test_group.cases %}
#[test]
#[ignore]
fn {{ test.description | make_ident }}() {
    let input = {{ self::render_tree(tree=test.input.tree) }};
    let from = "{{ test.input.from }}".to_string();
    {%- if test.property == "fromPov" -%}
        let result = input.pov_from(&from);
        {%- if not test.expected -%}
            let expected: Option<Tree<String>> = None;
        {%- else -%}
            let expected = Some({{ self::render_tree(tree=test.expected) }});
        {%- endif -%}
        assert_eq!(tree_to_sorted(result), tree_to_sorted(expected));
    {%- elif test.property == "pathTo" -%}
        let to = "{{ test.input.to }}".to_string();
        let result = input.path_to(&from, &to);
        {%- if not test.expected -%}
            let expected: Option<Vec<String>> = None;
        {%- else -%}
            let expected = Some({{ self::render_vec(values=test.expected) }});
        {%- endif -%}
        assert_eq!(result, expected);
    {%- else -%}
        Invalid property: {{ test.property }}
    {%- endif -%}
}
{% endfor %}
}
{% endfor %}

mod test_util {
    use pov::*;
    use std::fmt::Debug;

    pub fn tree_to_sorted<T: Ord + Clone + Debug>(
        tree_opt: Option<Tree<T>>,
    ) -> Option<Tree<T>> {
        tree_opt.map(sorter)
    }

    fn sorter<T: Ord + Clone + Debug>(tree: Tree<T>) -> Tree<T> {
        let mut children = tree.children();
        children.sort_unstable_by_key(|child| child.label());
        Tree::with_children(
            tree.label(),
            children.into_iter().cloned().map(|c| sorter(c)).collect(),
        )
    }
}
